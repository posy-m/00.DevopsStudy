# git

> git은 버전관리 시스템 (vcs) : 우리 소스 코드 파일의 변화를 기록하고
> 이후 특정 버전의 파일을 가져올 수 있는 vcs 이전 상태의 파일 상태로 돌릴 수 있다.
> 파일의 수정 내용을 비교해볼 수 있다. 쉽게 파일의 복구가 가능하다라는 것이 장점

## git의 개발 배경

> 리눅스 커널 개발자 리누스 토리발스가 소스코드나 파일 관리를 버전으로 관리하고 싶어서 고민하다가
> 만든게 git 이전에는 Bitkeeper라는 상용 버전 관리 시스템을 사용했지만
> 유로 버전이라 무료로 사용할 수 없는 이슈가 발생 사용하는 사용자들도 약관을 준수해야 했다.
> 하지만 사용자들이 요구사항에 잘 충족하지 못했고 문제가 발생했다.
> Bitkeeper의 사용을 중단하고 git을 개발하게 되었다.

## git의 버전 관리 > 버전관리 시스템의 저장소 (로컬)

> 혼자 프로젝트 작업을 하거나 협업을 하거나 소스코드를 관리하고 공유하고 이력을 관리하면서 개발해야한다.
> 우리가 일일이 파일을 관리하고 수정 내용에 주석을 하나하나 달아서 전달하면 너무 번거롭고 작업이 지연된다.
> git의 리눅스와 분산 버전 관리 시스템인 git의 창시자 리누스 토르발스도 같은 고민을 하면서 git을 개별한것.
> git은 리눅스 커널의 개발 과정을 위해 만들었고 지금은 많은 개발자들이 사용하는 버전 관리 시스템 중 하나가 된것.
> git hub와 같은 플랫폼에서 많은 개발자들이 소스코드를 공유하고 협업하는데 사용중
> git의 저장소를 생성해서 파일의 이력을 관리하고 버전을 관리할 수 있게 도와준다.

## git의 분산형 버전 관리

> git은 파일의 이력을 관리해주며 다른 저장소와 통신해서 저장소의 내용을 전송하거나 받을 수 있는 형태의 분산형 버전관리라고 한다.
> 즉 중앙 집중식 버전 관리가 아닌 각각의 사용자의 저장소의 변경내용을 다른 개발자와 공유할 수 있다.

### git을 사용해서 버전 관리를 하는 이유

> 우리가 프로그래밍을 할때 코드를 수정하고 테스트하고 지속적으로 작업을 진행하면서
> 불안한 수정사항이나 오류를 반복하는데 안정된 코드의 상태를 유지하기 위해서 고민을 해야한다.
> 그래서 버전으로 관리한느 것은 작업중인 코드의 내용을 버전으로 만들지 않고
> 안정된 코드의 상태를 버전을 줘서 안정된 소스코드 내용으로 구분
> 개발하면서 많은 기능을 추가하면서 안정된 상태의 복귀지점을 만들어 놓는것

## git의 버전 관리 시스템

> 한 파일을 작업하면서 이전 상태의 파일을 관리할때

project
project 2번 폰트 수정
project 3번 최종인가?
project 4번 진짜 최종
project 5번 진짜 진짜 마지막

> 이렇게 파일의 이름을 바꿔서 저장한 경험이 있을 수 있는데
> 드래곤볼 됨...........ㅠ 이렇게 작성한 이름은 파일을 찾기가 너무 힘들고 버전을 알아보기 힘들다.
> 우리는 코드를 작성하기 때문에 버전관리 소프트 웨어를 사용하는 것이 좋다.
> vcs는 크게 집중형과 분산형

## vcs 집중형

> 모든 소스 코드를 한곳에 집중해서 저장하는 형태 (저장소가 하나)
> 메인 중앙 서버에 팀원들의 모든 소스코드를 통합해서 관리한다.
> 중앙 서버가 관리하기 때문에 서버거 터지면 소스코드가 다 날아간다.
> 프로젝트의 이력이 모두 날아가고 작업하기 힘들다.
> 파일을 변경할때 순서대로 기다리다가 한명씩 진행한다.

## vcs 분산형 (git)

> 집중형과 다르게 저장소가 여러개 버전별로 파일로 보관한다.
> 분산 저장소 p2p (peer to peer) 각 팀원들이 서버이자 클리아언트도 될 수 있다.
> 저장소를 하나씩 관리하고 서버의 문제가 발생해도 개발을 진행할 수 있다.
> 즉 개발자가 로컬 컴퓨터에 소스코드나 파일을 저장하며 버전을 관리할 수 있다.
> 원격 저장소로 다른 개발자와 소스 코드를 배포 공유, 소스코드를 받아서 병합을 진행할 수 있다.

## git은 협업에 유용하다.

1. 소스코드 공유 가능

   > 이전에는 파일로 관리하는 경우도 있었다.

2. 코드나 파일의 이력 관리

   > 언제 누가 파일을 추가하거나 내용을 수정했는지 추적이 가능하다.(범인 찾깅..);

3. 원격 저장소 사용
   > 원격 저장소는 서버의 역할을 해준다. 저장소 간의 중개 역할만 해준다. 하나의 소스코드를 유지시키기 위해서
   > 병합 : 소스코드의 충돌점을 보여주고 사용자가 선택해서 코드를 병합하고 코드의 내용을 유지시킨다.
   > 코드 공개 : 코드를 공개해서 다른 개발자간의 프로젝트에 기여하거나 개인 프로젝트에서 사용할 수 있다.

## git의 동작

1. 초기화
   > 로컬에 깃 저장소를 만든다. (폴더단위)
2. 커밋
   > 변경할 커드의 내용과 이력을 기록한다.
3. 브랜치
   > 코드의 내용과 이력을 기록하는 공간을 나눠 놓은 것.
4. 병합 (머드)
   > 코드의 이력을 확인하고 이전내용과 비교해서 완성된 코드의 내용을 기록
5. 푸시
   > 로컬 저장소의 내용을 원격 저장소의 의력과 비교해서 서버에 전송 이후 공유
6. 풀
   > 로컬 저장소의 내용을 원격 저장소에서 가져와서 비교하고 병합하는 것.

풀 푸시를 해야함 푸시 풀 하면 안됨,
왜? 풀을 먼저해서 내 코드 내용을 병합을 한뒤에 내 수정파일과 이력을 푸쉬로 올려야한다.

> 동기화 -> 풀 + 푸쉬
> pull + push

## 1. git 설치

GIT 공식 홈페이지에 가서 git을 설치

```sh
git --version
```

## git Bash

> 윈도우 용 깃은 리눅스의 명령어를 실행할 수 있도록 git bash를 제공
> git 명령어는 대부분 git bash 터미널에서 사용
> ~ 현재 우리가 있는 경로 위치
> $는 유저라는 뜻 \_ 관리자로 접속하면 #root > 찾아보깅

## git의 명령어

```sh
git help --all  > 깃의 모든 명령어를 확인할 수 있다.
# 생활코딩에 지옥에서 온 git 시간이 나면
```

## git 설정

> 로컬 저장소에서 사용할 유저의 정보
> git은 환경 설정을 위해서 Config라는 명령어를 제공한다.
> config라는 명령어를 사용하면 환경 설정을 쉽게 할수 있도록 도와준다.

```sh
# 깃 저장소를 만들 폴더
mkdir 폴더명 # 새폴더 만든다.
cd GIT > mkdir study

#폴더 경로로 이동
cd 폴더명

# git 저장소 초기화
git init # 폴더 안에 .git 이라는 폴더가 생긴다.

# ls 폴더 디렉토리 내용 확인
ls

# 숨김 파일 모두 확인
ls -a

# 폴더안의 내용을 확인하고 싶다.
ls 폴더명
ls .git

# config의 내용을 우리가 직접 작성하지 않고

#써놓고
ls ~/.gitconfig # config의 경로를 확인
# 전역에 설치된 Config경로를 확인


#파일의 내용을 읽어서 출력
cat .git/config

# 편집기로 열어서 확인
code .git/config #vscode 편집기로 파일 열기

# 설정 파일 속성 추가 사용자 정보
git config user.name "posy-m"
git config user.email "https://github.com/posy-m"

# master로 되는데
git config init.defaultBranch main




맥은....
vim .git/config;
```

## git 저장소를 사용해 봅시다.

> 깃 초기화는 완전 비어있는 폴더 아니면 기존에 작업하던곳에서 가능하다.
> 작업할 공간에서 git 초기화를 진행해야한다.

- working directory

  > 작업을 하는 공간
  > 이 공간을 vcs 내용의 공간을 분리하는데 git을 어려워하는 이유 중 하나.

  **추적과 비추적**
  tracked가 된다는 것은 git의 소스코드 관리 대상으로 등록한다.

- stage (대기소)

  > 임시로 저장하는 공간
  > working directory에서 추가한 파일을 관리
  > 왜? 따로 추적할 파일의 내용이나 수정할 내용을 변경할 파일들의 차이점을 빠르게 처리하기 위해서
  > 이후에 기록을 한다. 대기소 역할만 하고 큰의미는 지금 두지 않을게용!

- repository

  > 기록하는 공간
  > 커밋을 진행하면 기록된다.

  ### git 명령어 대기소로 보내자

  ```sh
  git add 파일명 # 해당 파일을 대기소로 보냄
  git add . #모든 변경된 파일 내용을 대기소로 보냄

  #현재 대기소의 상태 확인
  # - 짧은 속성 오션 -- 긴속성 옵션
  git status
  을 쳤을때 untracked가 나오면 추적되고 있지 않다.
  않으면 git add 파일명을 치고
  git status를 다시 명령어를 실행시키면 new file : ~~ 이라고 나온다!

  ## 용어 staging 되었다.

  # git의 저장소에 기록된 내용을 확인하고 싶다.
  git log
  ```

# rm 대기소에서 제거 test.json 파일을 대기소에서 제거한다.

git rm --cached test.json

# repository 저장소에 기록

git commit -m "커밋의 메시지를 작성"
git commit -m "[feat] : 게시판 1번의 스크롤 기능 추가"
git commit -m "[feat] : json 추가"
git log를 찍음

```

**커밋 메시지 컨벤션 **
- feat : 새로운 기능을 추가하겠다.
- fix : 버그 수정
- docs : 문서를 수정사항이나
- style : 코드 스타일 변경 (세미콜론 누락이라서 수정했어)
- design : 사용자 웹페이지 UI 디자인 변경 (css)
- test : 테스트 코드 작성
- refactor : 리팩토리 햇어
- rename : 파일 이름 수정
- remove : 파일을 이동하거나 삭제했다.
```

- 커밋을 진행해서 저장소에 기록하게 되면 `스냅샷`, `델타 방식`
  스냅샷 -> 변경된 내용의 상태를 저장 (깃허브에서는 스냅샷으로 변경된 내용을 저장한다.)

  cf53b23f1f78223d30a5a4bb2f3cf85db3f684ee
  SHA1 쉽게 말해서 암호화햇음
  SHA -> 소스코드 알고리즘 (을 알려고 하지 말고 그냥 이런거구나 라고만 공부하기!)
  // 왜 만드냐면? 커밋의 내용이 겹치지 않게 하기 위해 해시값을 구해서 만든.

  vim
  :q! -> 강제로 나갈게!
  :q -> 그냥 나가기
  i -> 수정
  :wq! -> 저장하고 나갈게!

  ## HEAD

  > 우리가 현재 작업하고 있는 커밋의 위치
  > 브런치 우리가 작업하고 있는 공간나눈다고 했는데

  ## 이전 커밋으로 돌아가자

  ## 이전 해시로 HEAD를 이동시킨다.

  ```sh

  해시값은 git log를 통해 볼수 잇음
  git checkout 커밋 해시값
  git reset 커밋 해시값 // 지우는 것
  ```

  ## reset 이전 해시로 돌아가는 옵션중에서 hard

```sh
  git checkout 커밋 해시값
  git reset --hard 해시값
```

### git에서 파일 수정 내용을 추적하는걸 제외하고 싶다.

nodemodule

> .gitignore
> git에 수정 내용을 추적하지 않겠다. 이제 이후에 이 아핑ㄹ이 깃에 저장되는 일은 없을 것.

## 실습

> git bash열고 새폴더를 하나 만들고 원하는 이름으로 만들고
> 그폴더로 이동해서
> git 저장소 초기화
> working derectory html 파일 하나 만들고
> 파일을 수정하고 STage에 추가
> 상태를 확인하고
> 커밋 메시지 작성 커밋 진행 4번
> 상태확인 맨 마지막 커밋을 지워보세요

## 브런치를 다룰건데, 브런치 생성 합치고
